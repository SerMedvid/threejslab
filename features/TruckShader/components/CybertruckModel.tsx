/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.11 ../../../public/assets/TruckShader/cybertruck.gltf -t 
*/

import * as THREE from "three";
import React, { useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { extend, useFrame } from "@react-three/fiber";
import {
	DiscShaderMaterial,
	StripesShaderMaterial,
} from "./TruckShaderMaterial";
import { useControls } from "leva";

type GLTFResult = GLTF & {
	nodes: {
		interior001: THREE.Mesh;
		interior001_1: THREE.Mesh;
		interior001_2: THREE.Mesh;
		interior001_3: THREE.Mesh;
		interior001_4: THREE.Mesh;
		interior001_5: THREE.Mesh;
		interior001_6: THREE.Mesh;
		steer: THREE.Mesh;
		tires001: THREE.Mesh;
		tires001_1: THREE.Mesh;
	};
	materials: {
		lights: THREE.MeshStandardMaterial;
		body: THREE.MeshStandardMaterial;
		glass: THREE.MeshStandardMaterial;
		glassframes: THREE.MeshStandardMaterial;
		warninglights: THREE.MeshStandardMaterial;
		black: THREE.MeshStandardMaterial;
		shader: THREE.MeshStandardMaterial;
		gray: THREE.MeshStandardMaterial;
		tires: THREE.MeshStandardMaterial;
		rims: THREE.MeshStandardMaterial;
	};
};

type ContextType = Record<
	string,
	React.ForwardRefExoticComponent<JSX.IntrinsicElements["mesh"]>
>;

type Props = JSX.IntrinsicElements["group"];

extend({ DiscShaderMaterial, StripesShaderMaterial });

export function CybertruckModel(props: Props) {
	const { nodes, materials } = useGLTF(
		"/assets/TruckShader/cybertruck.gltf"
	) as GLTFResult;

	const shaderRef = useRef<THREE.ShaderMaterial>(null);

	const {
		type,
		Multiplier: uMultiplier,
		Alpha: uAlpha,
		Speed: uSpeed,
		ColorA: uColorA,
		ColorB: uColorB,
	} = useControls("Shader", {
		type: {
			options: {
				None: "",
				"Disc Shader": "disk",
				"Stripe Shader": "stripes",
			},
			value: "",
		},
		Multiplier: {
			value: 42,
			min: 1,
			max: 200,
		},
		Alpha: {
			value: 0.5,
			min: 0,
			max: 1,
		},
		Speed: {
			value: 1,
			min: -2,
			max: 2,
		},
		ColorA: "#ffff00",
		ColorB: "#0000ff",
	});

	useFrame((state) => {
		if (shaderRef.current) {
			shaderRef.current.uniforms.uTime.value = state.clock.elapsedTime;
		}
	});

	console.log(uColorA);

	useEffect(() => {
		materials.lights.toneMapped = false;
		materials.warninglights.toneMapped = false;
		materials.warninglights.color = new THREE.Color(82, 0, 0);
	}, [materials.lights, materials.warninglights]);

	return (
		<group
			{...props}
			dispose={null}
		>
			<mesh
				geometry={nodes.steer.geometry}
				material={materials.gray}
			/>
			<mesh
				geometry={nodes.interior001.geometry}
				material={materials.lights}
			/>
			<mesh
				geometry={nodes.interior001_1.geometry}
				castShadow
			>
				<meshStandardMaterial {...materials.body} />
			</mesh>
			<mesh geometry={nodes.interior001_2.geometry}>
				<meshStandardMaterial
					opacity={0.92}
					envMapIntensity={1}
					transparent
					roughness={0.2}
					color={"black"}
				/>
			</mesh>
			<mesh
				geometry={nodes.interior001_3.geometry}
				material={materials.glassframes}
				castShadow
			/>
			<mesh
				geometry={nodes.interior001_4.geometry}
				material={materials.warninglights}
			/>
			<mesh
				geometry={nodes.interior001_5.geometry}
				material={materials.black}
				castShadow
			/>

			{/* BODY MESH -> SHADER */}
			{type && (
				<mesh geometry={nodes.interior001_6.geometry}>
					{type === "disk" && (
						<discShaderMaterial
							key={Date.now().toString()}
							ref={shaderRef}
							transparent
							uniforms={{
								uAlpha: { value: uAlpha },
								uMultiplier: { value: uMultiplier },
								uTime: { value: 0 },
								uSpeed: { value: uSpeed },
								uColorA: { value: new THREE.Color(uColorA) },
								uColorB: { value: new THREE.Color(uColorB) },
							}}
						/>
					)}
					{type === "stripes" && (
						<stripesShaderMaterial
							key={Date.now().toString()}
							ref={shaderRef}
							transparent
							uniforms={{
								uAlpha: { value: uAlpha },
								uMultiplier: { value: uMultiplier },
								uTime: { value: 0 },
								uSpeed: { value: uSpeed },
								uColorA: { value: new THREE.Color(uColorA) },
								uColorB: { value: new THREE.Color(uColorB) },
							}}
						/>
					)}
				</mesh>
			)}

			<mesh
				geometry={nodes.tires001.geometry}
				material={materials.tires}
				castShadow
			/>
			<mesh
				geometry={nodes.tires001_1.geometry}
				material={materials.rims}
				castShadow
			/>
		</group>
	);
}

useGLTF.preload("/assets/TruckShader//cybertruck.gltf");
