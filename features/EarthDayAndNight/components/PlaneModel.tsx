/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.10 public/assets/EarthDayAndNight/scene.glb -t --output features/EarthDayAndNight/components/Pl.tsx 
*/

import React, { useEffect, useRef } from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame } from "@react-three/fiber";
import { Group, Mesh, MeshStandardMaterial, Vector3 } from "three";
import { nr } from "@/utils";
import useStore from "../stores/useStore";
import { gsap } from "gsap";

type GLTFResult = GLTF & {
	nodes: {
		Cube_2_2_Body_0_1: Mesh;
		Cube_2_2_Body_0_2: Mesh;
		Cube_2_2_Body_0_3: Mesh;
	};
	materials: {
		Body: MeshStandardMaterial;
		material: MeshStandardMaterial;
		Glass: MeshStandardMaterial;
	};
};

export function PlaneModel(props: JSX.IntrinsicElements["group"]) {
	const { nodes, materials } = useGLTF(
		"/assets/EarthDayAndNight/scene.glb"
	) as GLTFResult;

	const planeRef = useRef<Group>(null);
	const planeBodyRef = useRef<Group>(null);
	const tailRef = useRef<Mesh>(null);
	const rotRef = useRef<number>(Math.random() * Math.PI * 2);
	const radRef = useRef<number>(
		Math.random() * Math.PI * 0.45 + Math.PI * 0.05
	);
	const randAxisRef = useRef<Vector3>(
		new Vector3(nr(), nr(), nr()).normalize()
	);
	const randAxisRotRef = useRef<number>(Math.random() * Math.PI * 2);

	const { planeTrailMask } = useTexture({
		planeTrailMask: "/assets/EarthDayAndNight/mask.png",
	});

	const offset = 10.5 + Math.random();

	useEffect(() => {
		useStore.subscribe(
			(state) => state.isDay,
			(value) => {
				if (planeBodyRef.current) {
					planeBodyRef.current.traverse((obj) => {
						if (obj instanceof Mesh) {
							gsap.to(obj.material, {
								envMapIntencity: value ? 1 : 0.3,
							});
						}
					});
				}

				if (tailRef.current) {
					gsap.to(tailRef.current.material, {
						envMapIntencity: value ? 3 : 0.7,
					});
				}
			}
		);
	}, []);

	useFrame((state, delta) => {
		rotRef.current += delta * 0.25;

		if (planeRef.current) {
			planeRef.current.position.set(0, 0, 0);
			planeRef.current.rotation.set(0, 0, 0);
			planeRef.current.updateMatrixWorld();
			planeRef.current.rotateOnAxis(
				randAxisRef.current,
				randAxisRotRef.current
			);
			planeRef.current.rotateOnAxis(new Vector3(0, 1, 0), rotRef.current);
			planeRef.current.rotateOnAxis(new Vector3(0, 0, 1), radRef.current);
			planeRef.current.translateY(offset);

			planeRef.current.rotateOnAxis(new Vector3(1, 0, 0), +Math.PI * 0.5);
		}
	});

	return (
		<group
			{...props}
			ref={planeRef}
			dispose={null}
		>
			<group
				scale={0.001}
				rotation={[0, 0, 0]}
				position={[0, 0, 0]}
				ref={planeBodyRef}
			>
				<mesh
					geometry={nodes.Cube_2_2_Body_0_1.geometry}
					material={materials.Body}
					receiveShadow
					castShadow
				/>
				<mesh
					geometry={nodes.Cube_2_2_Body_0_2.geometry}
					material={materials.material}
					castShadow
					receiveShadow
				/>
				<mesh
					geometry={nodes.Cube_2_2_Body_0_3.geometry}
					material={materials.Glass}
					receiveShadow
				/>
			</group>
			<mesh
				rotation-x={Math.PI}
				ref={tailRef}
				position-y={-1.1}
			>
				<planeGeometry args={[1, 2]} />
				<meshPhysicalMaterial
					envMapIntensity={3}
					roughness={0.4}
					metalness={0}
					transmission={1}
					transparent
					opacity={1}
					alphaMap={planeTrailMask}
				/>
			</mesh>
		</group>
	);
}

useGLTF.preload("/assets/EarthDayAndNight/scene.glb");
