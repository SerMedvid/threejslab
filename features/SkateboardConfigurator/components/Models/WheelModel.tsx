/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/assets/SkateboardConfigurator/skateboard-wheels.glb -o features/SkateboardConfigurator/components/Models/wheelsModel.tsx -t 
*/

import * as THREE from "three";
import React, { useEffect, useMemo, useRef } from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { ConfigurationPhase, SlideModel } from "../../types";
import useStore from "../../stores/useStore";
import gsap from "gsap";
import ThreeCustomShaderMaterial from "three-custom-shader-material/vanilla";
import fragmentShader from "../../shaders/wheel-transition/fragment.glsl";
import vertexShader from "../../shaders/wheel-transition/vertex.glsl";
import { shallow } from "zustand/shallow";
import { wheelApperAnimation } from "../../animation/wheelModelAnimation";

type GLTFResult = GLTF & {
	nodes: {
		["WheelsBase_-_FL"]: THREE.Mesh;
		["WheelsBase_-_FR"]: THREE.Mesh;
		["WheelsBase-_BR"]: THREE.Mesh;
		["WheelsBase_-_BL"]: THREE.Mesh;
	};
	materials: {
		["Wheels - Base Color"]: THREE.MeshStandardMaterial;
	};
};

type Props = SlideModel & {
	transitionCallback?: (
		material: ThreeCustomShaderMaterial,
		offset: number
	) => void;
};

export function WheelModel({
	texture,
	manageOpacity = true,
	transitionCallback,
	...props
}: Props) {
	const { nodes, materials } = useGLTF(
		"/assets/SkateboardConfigurator/models/skateboard-wheels.glb"
	) as GLTFResult;

	const wheel1Ref = useRef<THREE.Mesh>(null);
	const wheel2Ref = useRef<THREE.Mesh>(null);
	const wheel3Ref = useRef<THREE.Mesh>(null);
	const wheel4Ref = useRef<THREE.Mesh>(null);

	const { textureMap, aoMap } = useTexture({
		textureMap: texture,
		aoMap:
			"/assets/SkateboardConfigurator/textures/wheel/Wheels_Bake1_PBR_Ambient Occlusion.png",
	});

	textureMap.flipY = false;
	textureMap.colorSpace = THREE.SRGBColorSpace;
	aoMap.flipY = false;

	const material = useMemo(() => {
		const mat = new ThreeCustomShaderMaterial({
			baseMaterial: materials["Wheels - Base Color"],
			fragmentShader: fragmentShader,
			vertexShader: vertexShader,
			silent: true,
			map: textureMap,
			uniforms: {
				uStartTexture: { value: textureMap },
				uEndTexture: { value: textureMap },
				uProgress: { value: 0 },
			},
			opacity: manageOpacity ? 0 : 1,
			transparent: true,
		});

		return mat;
	}, [materials, textureMap, manageOpacity]);

	const dragOffset = useRef(Math.PI);
	const setMovementX = useStore((state) => state.setMovementX);

	useEffect(() => {
		const unsubscribe = useStore.subscribe(
			(state) => ({
				movementX: state.movementX,
				isSwiping: state.isSwiping,
				isWheelPhase: state.configurationPhase === ConfigurationPhase.WHEEL,
			}),
			(data) => {
				const { movementX, isSwiping, isWheelPhase } = data;

				if (!isWheelPhase) {
					return;
				}

				if (
					!isWheelPhase ||
					!movementX ||
					!wheel1Ref.current ||
					!wheel2Ref.current ||
					!wheel3Ref.current ||
					!wheel4Ref.current
				) {
					return;
				}

				if (isSwiping) {
					dragOffset.current += movementX / 50;

					wheel1Ref.current.rotation.z = dragOffset.current;
					wheel2Ref.current.rotation.z = dragOffset.current;
					wheel3Ref.current.rotation.z = dragOffset.current;
					wheel4Ref.current.rotation.z = dragOffset.current;
				} else {
					gsap.to(
						[
							wheel1Ref.current.rotation,
							wheel2Ref.current.rotation,
							wheel3Ref.current.rotation,
							wheel4Ref.current.rotation,
						],
						{
							z: Math.PI,
							duration: 0.5,
							ease: "power2.out",
							onComplete: () => {
								dragOffset.current = Math.PI;
								setMovementX(0);
							},
						}
					);

					if (
						Math.abs(dragOffset.current) > 3.5 &&
						material &&
						transitionCallback
					) {
						const offsetDirection = Math.sign(dragOffset.current);

						transitionCallback(material, offsetDirection * -1);
					}
				}
			},
			{ equalityFn: shallow }
		);

		return () => {
			unsubscribe();
		};
	}, [material, setMovementX, transitionCallback]);

	/** Enter animation */
	useEffect(() => {
		const unsubscribe = useStore.subscribe(
			(state) => state.configurationPhase === ConfigurationPhase.WHEEL,
			(isWheelPhase) => {
				if (!isWheelPhase || !wheel2Ref.current) {
					return;
				}

				wheelApperAnimation(wheel2Ref, material);
			}
		);

		return () => {
			unsubscribe();
		};
	}, [material]);

	return (
		<group
			{...props}
			dispose={null}
		>
			<mesh
				rotation-z={Math.PI}
				visible={!manageOpacity}
				ref={wheel1Ref}
				geometry={nodes["WheelsBase_-_FL"].geometry}
				material={material}
				position={[1.055, -0.271, -0.345]}
				rotation={[Math.PI, 0, Math.PI]}
			/>
			<mesh
				rotation-z={Math.PI}
				ref={wheel2Ref}
				geometry={nodes["WheelsBase_-_FR"].geometry}
				material={material}
				position={[1.055, -0.271, 0.345]}
			/>
			<mesh
				rotation-z={Math.PI}
				visible={!manageOpacity}
				ref={wheel3Ref}
				geometry={nodes["WheelsBase-_BR"].geometry}
				material={material}
				position={[-1.055, -0.271, 0.345]}
			/>
			<mesh
				rotation-z={Math.PI}
				visible={!manageOpacity}
				ref={wheel4Ref}
				geometry={nodes["WheelsBase_-_BL"].geometry}
				material={material}
				position={[-1.055, -0.271, -0.345]}
				rotation={[Math.PI, 0, Math.PI]}
			/>
		</group>
	);
}

useGLTF.preload("/assets/SkateboardConfigurator/models/skateboard-wheels.glb");

useTexture.preload(
	"/assets/SkateboardConfigurator/textures/wheel/Wheels_Bake1_PBR_Ambient Occlusion.png"
);
