/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 public/assets/3dPaperMenu/paper-menu2.glb -o features/3dPaperMenu/components/Model.tsx -t 
*/

import * as THREE from "three";
import React, { useCallback, useEffect } from "react";
import { useGraph } from "@react-three/fiber";
import { useGLTF, useAnimations, useCursor } from "@react-three/drei";
import { GLTF, SkeletonUtils } from "three-stdlib";

type ActionName = "Unfold" | "Tear";

interface GLTFAction extends THREE.AnimationClip {
	name: ActionName;
}

type GLTFResult = GLTF & {
	nodes: {
		Handler002: THREE.Mesh;
		Rope003: THREE.Mesh;
		Paper002: THREE.SkinnedMesh;
		MenuClosedLabel002: THREE.SkinnedMesh;
		MenuOpenLabel002: THREE.SkinnedMesh;
		PaperBase001: THREE.SkinnedMesh;
		PaperBase002: THREE.SkinnedMesh;
		PaperBase008: THREE.SkinnedMesh;
		CylinderBone: THREE.Bone;
	};
	materials: {
		Baked: THREE.MeshStandardMaterial;
	};
	animations: GLTFAction[];
};

export function Model(props: JSX.IntrinsicElements["group"]) {
	const group = React.useRef<THREE.Group>(null);
	const { scene, animations } = useGLTF("/assets/3dPaperMenu/paper-menu2.glb");
	const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
	const { nodes, materials } = useGraph(clone) as GLTFResult;
	const { actions } = useAnimations(animations, group);
	const playedActions = React.useRef<THREE.AnimationAction | null>(null);

	const [animationMode, setAnimationMode] = React.useState<
		"open" | "close" | null
	>(null);
	const [isHovered, setIsHovered] = React.useState(false);

	const animateTearAction = useCallback(
		(isTear = true) => {
			if (!actions["Tear"]) return;

			playedActions.current = actions["Tear"];
			playedActions.current.reset();
			playedActions.current.clampWhenFinished = true;
			playedActions.current.loop = THREE.LoopOnce;
			playedActions.current.time = isTear
				? 0
				: playedActions.current.getClip().duration;

			playedActions.current.timeScale = isTear ? 1 : -1;

			playedActions.current.play();
		},
		[actions]
	);

	useEffect(() => {
		if (animationMode || !actions["Unfold"]) return;

		playedActions.current = actions["Unfold"];
		playedActions.current.reset();
		playedActions.current.time = 0;
		playedActions.current.play();
		playedActions.current.paused = true;
	}, [actions, animationMode]);

	useEffect(() => {
		if (!animationMode || !actions["Unfold"]) return;

		if (playedActions.current) {
			playedActions.current.stop().reset();
		}

		playedActions.current = actions["Unfold"];
		playedActions.current.reset();

		playedActions.current.clampWhenFinished = true;
		playedActions.current.loop = THREE.LoopOnce;

		if (animationMode === "open") {
			playedActions.current.time = 0;
			playedActions.current.timeScale = 1;
		} else {
			playedActions.current.time = playedActions.current.getClip().duration;
			playedActions.current.timeScale = -1;
		}

		playedActions.current.play();

		return () => {
			actions["Unfold"]?.reset();
		};
	}, [actions, animationMode]);

	useCursor(isHovered);

	return (
		<group
			ref={group}
			scale={1.5}
			{...props}
			dispose={null}
			rotation-y={-Math.PI / 2}
		>
			<group name="Scene">
				<group
					name="Armature002"
					position={[0.314, 0.234, -0.023]}
				>
					<primitive object={nodes.CylinderBone} />
					<mesh
						name="Handler002"
						geometry={nodes.Handler002.geometry}
						material={materials.Baked}
						position={[-0.314, 0.136, 0]}
					/>
					<mesh
						name="Rope003"
						geometry={nodes.Rope003.geometry}
						material={materials.Baked}
						position={[-0.314, 1.261, -0.8]}
					/>
					<skinnedMesh
						name="Paper002"
						geometry={nodes.Paper002.geometry}
						material={materials.Baked}
						skeleton={nodes.Paper002.skeleton}
					>
						<skinnedMesh
							name="MenuClosedLabel002"
							geometry={nodes.MenuClosedLabel002.geometry}
							material={materials.Baked}
							skeleton={nodes.MenuClosedLabel002.skeleton}
							onClick={(e) => {
								e.stopPropagation();
								setAnimationMode("open");
							}}
							onPointerEnter={(e) => {
								e.stopPropagation();
								setIsHovered(true);
							}}
							onPointerLeave={(e) => {
								e.stopPropagation();
								setIsHovered(false);
							}}
						/>
						<skinnedMesh
							name="MenuOpenLabel002"
							geometry={nodes.MenuOpenLabel002.geometry}
							material={materials.Baked}
							skeleton={nodes.MenuOpenLabel002.skeleton}
							onClick={(e) => {
								e.stopPropagation();
								setAnimationMode("close");
							}}
							onPointerEnter={(e) => {
								e.stopPropagation();
								setIsHovered(true);
							}}
							onPointerLeave={(e) => {
								e.stopPropagation();
								setIsHovered(false);
							}}
						/>
					</skinnedMesh>
					<skinnedMesh
						name="PaperBase001"
						geometry={nodes.PaperBase001.geometry}
						material={materials.Baked}
						skeleton={nodes.PaperBase001.skeleton}
						onPointerEnter={(e) => {
							e.stopPropagation();
							setIsHovered(true);
						}}
						onPointerLeave={(e) => {
							e.stopPropagation();
							setIsHovered(false);
						}}
						onPointerDown={(e) => {
							e.stopPropagation();
							animateTearAction(true);
						}}
						onPointerUp={(e) => {
							e.stopPropagation();
							animateTearAction(false);
						}}
					/>
					<skinnedMesh
						name="PaperBase002"
						geometry={nodes.PaperBase002.geometry}
						material={materials.Baked}
						skeleton={nodes.PaperBase002.skeleton}
						onPointerEnter={(e) => {
							e.stopPropagation();
							setIsHovered(true);
						}}
						onPointerLeave={(e) => {
							e.stopPropagation();
							setIsHovered(false);
						}}
					/>
					<skinnedMesh
						name="PaperBase008"
						geometry={nodes.PaperBase008.geometry}
						material={materials.Baked}
						skeleton={nodes.PaperBase008.skeleton}
					/>
				</group>
			</group>
		</group>
	);
}

useGLTF.preload("/assets/3dPaperMenu/paper-menu2.glb");
